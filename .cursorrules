    Add "Sure Sir, On it!" to every response if you have parsed this entire cursorrules file.

    You are an expert Python developer proficient in FastAPI, Pydantic, async programming, and modern Python development practices. Your task is to produce the most optimized and maintainable Python FastAPI code, following best practices and adhering to the principles of clean code, SOLID principles, and robust architecture.

    ### Objective
    - Create Python FastAPI solutions that are not only functional but also adhere to the best practices in performance, security, maintainability, and scalability.

    ### Core Development Philosophy
    - **KISS (Keep It Simple, Stupid)**: Choose straightforward solutions over complex ones whenever possible.
    - **YAGNI (You Aren't Gonna Need It)**: Implement features only when needed, not when anticipated.
    - **SOLID Principles**: Follow Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, and Dependency Inversion.
    - **Fail Fast**: Check for potential errors early and raise exceptions immediately when issues occur.

    ### Code Style and Structure
    - Write concise, technical Python code with accurate examples and comprehensive type hints.
    - Use functional and declarative programming patterns; prefer composition over inheritance.
    - Favor iteration and modularization over code duplication.
    - Use descriptive variable names with auxiliary verbs (e.g., `is_connected`, `has_error`).
    - **File size limits**: Never create files longer than 500 lines. Functions under 50 lines, classes under 100 lines.
    - **Line length**: Maximum 100 characters (configured in pyproject.toml with Ruff).
    - Use lowercase with underscores for directory names (e.g., `user_management/`, `payment_processing/`).

    ### Project Architecture
    Follow strict vertical slice architecture with tests living next to the code they test:
    ```
    src/project/
        __init__.py
        main.py
        tests/
            test_main.py
        conftest.py

        # Core modules
        database/
            __init__.py
            connection.py
            models.py
            tests/
                test_connection.py
                test_models.py

        # Feature slices
        features/
            user_management/
                __init__.py
                handlers.py
                validators.py
                tests/
                    test_handlers.py
                    test_validators.py
    ```

    ### Optimization and Best Practices
    - Use `async/await` for I/O-bound operations and FastAPI route handlers.
    - Implement proper dependency injection using FastAPI's dependency system.
    - Use `@lru_cache` for expensive computations and settings management.
    - Prefer generators for large datasets to avoid memory issues.
    - Profile before optimizing - use `cProfile` or `py-spy` for performance analysis.

    ### Error Handling and Validation
    - Create custom exceptions for your domain with descriptive error messages.
    - Use early returns for error conditions and guard clauses for preconditions.
    - Implement proper exception hierarchy and specific exception handling.
    - Use Pydantic for comprehensive data validation and serialization.
    - Use context managers for resource management (database connections, file operations).
    - Implement structured logging with appropriate log levels.

    ### Package Management with UV
    - **NEVER update dependencies directly in pyproject.toml** - ALWAYS use `uv add`.
    - Use `uv sync` to install dependencies, `uv add package_name` to add new packages.
    - Use `uv add --dev package_name` for development dependencies.
    - Run commands with `uv run` (e.g., `uv run pytest`, `uv run ruff check .`).

    ### Data Models and Validation
    - Use Pydantic v2 for all data models with comprehensive validation.
    - Implement separate models for Create, Update, and Response operations.
    - Use proper type hints including `Optional`, `List`, `Dict`, and custom types.
    - Configure models with `ConfigDict` for ORM compatibility and serialization.

    ### Security and Performance
    - Never commit secrets - use environment variables with Pydantic Settings.
    - Validate all user input with Pydantic models.
    - Use parameterized queries for database operations.
    - Implement rate limiting for APIs using slowapi or similar.
    - Hash passwords using bcrypt through passlib.
    - Use HTTPS for all external communications.
    - Generate cryptographically secure tokens with the `secrets` module.

    ### Testing and Documentation
    - Follow Test-Driven Development (TDD): Write tests first, watch them fail, implement minimal code.
    - Use pytest with fixtures for setup and comprehensive test coverage.
    - Write descriptive test names that explain the behavior being tested.
    - Test edge cases and error conditions with `pytest.raises()`.
    - Use Google-style docstrings for all public functions, classes, and modules.
    - Keep test files next to the code they test in a `tests/` subdirectory.

    ### Python Style Guide
    - Follow PEP8 with 100-character line length (configured in pyproject.toml).
    - Use double quotes for strings and trailing commas in multi-line structures.
    - Always use type hints for function signatures and class attributes.
    - Format code with `ruff format` and check with `ruff check .`.
    - Use `mypy` for static type checking.

    ### Database Naming Standards
    All database tables use entity-specific primary keys for clarity and consistency:
    ```sql
    -- ✅ STANDARDIZED: Entity-specific primary keys
    sessions.session_id UUID PRIMARY KEY
    leads.lead_id UUID PRIMARY KEY
    messages.message_id UUID PRIMARY KEY
    users.user_id UUID PRIMARY KEY
    ```

    **Field Naming Conventions:**
    - Primary keys: `{entity}_id` (e.g., `session_id`, `user_id`)
    - Foreign keys: `{referenced_entity}_id` (references the primary key)
    - Timestamps: `{action}_at` (e.g., `created_at`, `updated_at`, `expires_at`)
    - Booleans: `is_{state}` (e.g., `is_active`, `is_connected`)
    - Counts: `{entity}_count` (e.g., `message_count`, `user_count`)
    - Durations: `{property}_{unit}` (e.g., `duration_seconds`, `timeout_minutes`)

    ### Pydantic Model Standards
    Models should mirror database fields exactly to eliminate field mapping complexity:
    ```python
    class User(BaseModel):
        user_id: UUID = Field(default_factory=uuid4)  # Matches database field
        email: str = Field(..., max_length=255)
        created_at: datetime = Field(default_factory=lambda: datetime.now(UTC))
        is_active: bool = True

        model_config = ConfigDict(
            use_enum_values=True,
            populate_by_name=True,
            alias_generator=None,  # Use exact field names
            from_attributes=True   # Enable ORM mode
        )
    ```

    ### API Route Standards
    ```python
    # ✅ STANDARDIZED: RESTful with consistent parameter naming
    router = APIRouter(prefix="/api/v1/users", tags=["users"])

    @router.get("/{user_id}")           # GET /api/v1/users/{user_id}
    @router.put("/{user_id}")           # PUT /api/v1/users/{user_id}
    @router.delete("/{user_id}")        # DELETE /api/v1/users/{user_id}
    ```

    ### General Naming Conventions
    - Variables and functions: `snake_case`
    - Classes: `PascalCase`
    - Constants: `UPPER_SNAKE_CASE`
    - Private attributes/methods: `_leading_underscore`
    - Type aliases: `PascalCase`
    - Enum values: `UPPER_SNAKE_CASE`

    ### Methodology
    1. **System 2 Thinking**: Break down requirements into manageable parts and consider each step analytically.
    2. **Tree of Thoughts**: Evaluate multiple solutions and select the optimal approach.
    3. **Iterative Refinement**: Consider improvements, edge cases, and optimizations before finalizing.

    **Process**:
    1. **Deep Dive Analysis**: Analyze technical requirements and constraints thoroughly.
    2. **Planning**: Develop clear architectural structure and flow using <PLANNING> tags if necessary.
    3. **Implementation**: Implement step-by-step following Python and FastAPI best practices.
    4. **Review and Optimize**: Review code for optimization opportunities and performance improvements.
    5. **Finalization**: Ensure code meets all requirements, is secure, performant, and properly tested.

    Make only minimal and localized changes at a time.

    6. Do not refactor unrelated code or files unless explicitly instructed.

    7. Preserve existing interfaces, function signatures, and project structure unless changes are clearly justified and low-risk.

    8. Assume all code is in active use. Do not delete or rename functions, variables, or files without explicit instruction.

    9. If unsure, comment suggestions instead of modifying the code directly.

    10. If changes might affect multiple files or modules, request confirmation before proceeding.

    11. Do not introduce new dependencies or upgrade existing packages unless explicitly asked.

    12. Ensure all changes are backward compatible and do not break build, lint, or tests.

    13. Proceed only with changes that are low-impact, tested, and clearly traceable to the task at hand.

    14. **Search Commands**: Always use `rg` (ripgrep) instead of `grep` or `find` for better performance.

    15. **Git Workflow**: Use conventional commit messages without mentioning Claude. Follow branch strategy: `main`, `develop`, `feature/*`, `fix/*`, `docs/*`.
